"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = require("crypto");
const secp256k1Funs = require('secp256k1');
/** secp256k1 methods set */
var secp256k1;
(function (secp256k1) {
    /** generate private key  */
    function generatePrivateKey() {
        for (;;) {
            const privKey = crypto_1.randomBytes(32);
            if (secp256k1Funs.privateKeyVerify(privKey)) {
                return privKey;
            }
        }
    }
    secp256k1.generatePrivateKey = generatePrivateKey;
    /**
     * derive public key(uncompressed) from private key
     * @param privKey the private key
     */
    function derivePublicKey(privKey) {
        return secp256k1Funs.publicKeyCreate(privKey, false /* uncompressed */);
    }
    secp256k1.derivePublicKey = derivePublicKey;
    /**
     * sign a message using elliptic curve algorithm on the curve secp256k1
     * @param msgHash hash of message
     * @param privKey serialized private key
     */
    function sign(msgHash, privKey) {
        const sig = secp256k1Funs.sign(msgHash, privKey);
        const packed = Buffer.alloc(65);
        sig.signature.copy(packed);
        packed[64] = sig.recovery;
        return packed;
    }
    secp256k1.sign = sign;
    /**
     * recovery signature to public key
     * @param msgHash hash of message
     * @param sig signature
     */
    function recover(msgHash, sig) {
        if (sig.length !== 65) {
            throw new Error('invalid signature');
        }
        const recovery = sig[64];
        if (recovery !== 0 && recovery !== 1) {
            throw new Error('invalid signature recovery');
        }
        return secp256k1Funs.recover(msgHash, sig.slice(0, 64), recovery, false);
    }
    secp256k1.recover = recover;
})(secp256k1 = exports.secp256k1 || (exports.secp256k1 = {}));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VjcDI1NmsxLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2NyeS9zZWNwMjU2azEudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxtQ0FBb0M7QUFDcEMsTUFBTSxhQUFhLEdBQUcsT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUFBO0FBRTFDLDRCQUE0QjtBQUM1QixJQUFpQixTQUFTLENBZ0R6QjtBQWhERCxXQUFpQixTQUFTO0lBQ3RCLDRCQUE0QjtJQUM1QjtRQUNJLFNBQVU7WUFDTixNQUFNLE9BQU8sR0FBRyxvQkFBVyxDQUFDLEVBQUUsQ0FBQyxDQUFBO1lBQy9CLElBQUksYUFBYSxDQUFDLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxFQUFFO2dCQUN6QyxPQUFPLE9BQU8sQ0FBQTthQUNqQjtTQUNKO0lBQ0wsQ0FBQztJQVBlLDRCQUFrQixxQkFPakMsQ0FBQTtJQUVEOzs7T0FHRztJQUNILHlCQUFnQyxPQUFlO1FBQzNDLE9BQU8sYUFBYSxDQUFDLGVBQWUsQ0FBQyxPQUFPLEVBQUUsS0FBSyxDQUFDLGtCQUFrQixDQUFXLENBQUE7SUFDckYsQ0FBQztJQUZlLHlCQUFlLGtCQUU5QixDQUFBO0lBRUQ7Ozs7T0FJRztJQUNILGNBQXFCLE9BQWUsRUFBRSxPQUFlO1FBQ2pELE1BQU0sR0FBRyxHQUFHLGFBQWEsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFBO1FBQ2hELE1BQU0sTUFBTSxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUE7UUFDL0IsR0FBRyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUE7UUFDMUIsTUFBTSxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxRQUFRLENBQUE7UUFDekIsT0FBTyxNQUFNLENBQUE7SUFDakIsQ0FBQztJQU5lLGNBQUksT0FNbkIsQ0FBQTtJQUVEOzs7O09BSUc7SUFDSCxpQkFBd0IsT0FBZSxFQUFFLEdBQVc7UUFDaEQsSUFBSSxHQUFHLENBQUMsTUFBTSxLQUFLLEVBQUUsRUFBRTtZQUNuQixNQUFNLElBQUksS0FBSyxDQUFDLG1CQUFtQixDQUFDLENBQUE7U0FDdkM7UUFDRCxNQUFNLFFBQVEsR0FBRyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUE7UUFDeEIsSUFBSSxRQUFRLEtBQUssQ0FBQyxJQUFJLFFBQVEsS0FBSyxDQUFDLEVBQUU7WUFDbEMsTUFBTSxJQUFJLEtBQUssQ0FBQyw0QkFBNEIsQ0FBQyxDQUFBO1NBQ2hEO1FBRUQsT0FBTyxhQUFhLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxRQUFRLEVBQUUsS0FBSyxDQUFXLENBQUE7SUFDdEYsQ0FBQztJQVZlLGlCQUFPLFVBVXRCLENBQUE7QUFDTCxDQUFDLEVBaERnQixTQUFTLEdBQVQsaUJBQVMsS0FBVCxpQkFBUyxRQWdEekIifQ==